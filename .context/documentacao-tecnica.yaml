documentacao_mvp:
projeto:
  nome: "Lino's Padaria MVP"
  versao: "1.0.0"
  objetivo: >
    Desenvolver um MVP funcional para a gestão de pedidos B2B da padaria, operando localmente e offline.
    O sistema deverá gerenciar cadastros básicos de produtos, clientes, pedidos (e itens do pedido),
    calcular automaticamente os valores, gerar PDFs simples para cada pedido e permitir a repetição de pedidos
    antigos para agilizar novos cadastros.
  escopo_mvp:
    - "Cadastro e gerenciamento básico de produtos e clientes com campos mínimos obrigatórios."
    - "Criação, edição e cancelamento de pedidos com cálculo automático e geração de PDF."
    - "Listagem de produtos, clientes e pedidos com paginação de 10 itens por página."
    - "Funcionalidade de 'repetir pedido' a partir de pedidos antigos."
    - "Relatórios simples com filtros básicos (ex.: por data e cliente)."
    - "Operação local e offline para uma única unidade."

arquitetura:
  descricao: >
    Arquitetura simples e modular, baseada nos princípios do Clean Architecture e DDD, mas focada apenas
    nas funcionalidades essenciais do MVP. As camadas foram definidas de forma a minimizar complexidade
    e garantir a integração consistente entre front-end, back-end e banco de dados, priorizando simplicidade
    e facilidade de manutenção com SQLite como banco de dados.
  camadas:
    dominio: "Entidades mínimas: Produto, Cliente, Pedido, ItensPedido."
    aplicacao: "Casos de uso básicos para operações CRUD, geração de PDF e repetição de pedidos."
    infraestrutura: "Integração com SQLite via Prisma e regras de negócio simplificadas."
    apresentacao: "Interface web local (Next.js) e API REST simples (NestJS)."

stack_tecnologico:
  frontend:
    framework: "Next.js"
    versao: "13"
    linguagem: "TypeScript"
    ui_framework: "Material-UI (MUI)"
    versao_mui: "5"
    gerenciamento_estado: "React Context"
    observacoes: >
      Interface local e simples, sem necessidade de recursos avançados de SEO ou SSR, focando na usabilidade e
      facilidade de navegação com paginação (10 itens por página) e funcionalidade de repetir pedidos.
  backend:
    plataforma: "Node.js"
    versao: "20 LTS"
    framework: "NestJS"
    versao_nestjs: "10"
    linguagem: "TypeScript"
    servidor_web: "Express (integrado ao NestJS)"
    observacoes: >
      API REST simples para operações CRUD e geração de PDF. O endpoint para repetir pedidos antigos agiliza
      o fluxo de cadastro.
  acesso_a_dados:
    orm: "Prisma"
    versao: "5.x"
    banco_dados: "SQLite"
    versao_sqlite: "3"
    observacoes: >
      Escolha ideal para MVP offline, oferecendo zero configuração, arquivo único de banco,
      backup simplificado e excelente integração com Prisma. Suporta perfeitamente o volume
      de dados esperado e paginação necessária.
  geracao_pdf:
    biblioteca: "Puppeteer"
    versao: "19+"
    observacoes: >
      Geração de PDFs a partir de templates HTML simples renderizados via Next.js.
  autenticacao:
    metodo: "Implementação simples (a ser aprimorada pós-MVP)"
    observacoes: >
      Devido ao ambiente local e offline, autenticação avançada não é prioritária para o MVP e poderá ser
      incorporada em uma fase futura.
  pagination:
    descricao: "Listagem de produtos, clientes e pedidos com paginação de 10 itens por página, conforme boas práticas."

estrutura_banco:
  tabelas:
    Produto:
      campos:
        - id: "Integer, PK, autoincrement"
        - nome: "Text, NOT NULL"
        - preco_unitario: "Real, NOT NULL"
        - tipo_medida: "Text, NOT NULL (ex.: 'kg', 'unidade')"
        - status: "Text, NOT NULL ('ativo' ou 'inativo')"
    Cliente:
      campos:
        - id: "Integer, PK, autoincrement"
        - cnpj: "Text, NOT NULL, UNIQUE"
        - razao_social: "Text, NOT NULL"
        - nome_fantasia: "Text, NOT NULL"
        - telefone: "Text, NOT NULL"
        - email: "Text, NOT NULL"
        - status: "Text, NOT NULL ('ativo' ou 'inativo')"
    Pedido:
      campos:
        - id: "Integer, PK, autoincrement"
        - cliente_id: "Integer, FK para Cliente, NOT NULL"
        - data_pedido: "Text, NOT NULL (ISO8601)"
        - status: "Text, NOT NULL ('novo', 'finalizado', 'cancelado')"
        - valor_total: "Real, NOT NULL"
        - caminho_pdf: "Text, NOT NULL"
    ItensPedido:
      campos:
        - id: "Integer, PK, autoincrement"
        - pedido_id: "Integer, FK para Pedido, NOT NULL"
        - produto_id: "Integer, FK para Produto, NOT NULL"
        - quantidade: "Real, NOT NULL"
        - preco_unitario: "Real, NOT NULL (valor no momento do pedido)"
        - valor_total_item: "Real, NOT NULL (quantidade * preco_unitario)"

prisma_schema: |
  datasource db {
    provider = "sqlite"
    url      = "file:./dev.db"
  }

  generator client {
    provider = "prisma-client-js"
  }

  model Produto {
    id             Int       @id @default(autoincrement())
    nome           String
    preco_unitario Float
    tipo_medida    String
    status         String
    itensPedido    ItensPedido[]
  }

  model Cliente {
    id            Int       @id @default(autoincrement())
    cnpj          String    @unique
    razao_social  String
    nome_fantasia String
    telefone      String
    email         String
    status        String
    pedidos       Pedido[]
  }

  model Pedido {
    id          Int       @id @default(autoincrement())
    cliente_id  Int
    data_pedido DateTime
    status      String
    valor_total Float
    caminho_pdf String
    cliente     Cliente   @relation(fields: [cliente_id], references: [id])
    itensPedido ItensPedido[]
  }

  model ItensPedido {
    id               Int      @id @default(autoincrement())
    pedido_id        Int
    produto_id       Int
    quantidade       Float
    preco_unitario   Float
    valor_total_item Float
    pedido           Pedido   @relation(fields: [pedido_id], references: [id])
    produto          Produto  @relation(fields: [produto_id], references: [id])
  }

integracao:
  descricao: >
    O back-end (NestJS) expõe uma API REST simples para operações CRUD, listagem com paginação e geração de PDFs.
    O front-end (Next.js) consome esses endpoints para gerenciar cadastros, listagens e a funcionalidade de repetir pedidos.
    A listagem exibirá 10 itens por página, e um endpoint específico permitirá repetir um pedido antigo como base para um novo.
  seguranca:
    observacoes: >
      Devido ao ambiente local e offline, medidas avançadas de segurança são menos críticas no MVP.
      Funcionalidades de autenticação robusta serão planejadas para fases futuras.

testes:
  unitarios:
    objetivo: "Validar funções e métodos essenciais de cada módulo."
    ferramenta: "Jest v29.x"
    meta: ">= 80% de cobertura"
  integracao:
    objetivo: "Verificar a comunicação entre API e banco de dados."
    ferramenta: "SuperTest (integrado ao Jest)"
    ambiente: "Uso de arquivo SQLite dedicado para testes"
  e2e:
    objetivo: "Simular fluxos críticos (ex.: criação, repetição de pedido e geração de PDF)."
    ferramenta: "Jest + SuperTest"
  ci_cd:
    descricao: "Pipeline simples no GitHub Actions para executar testes e linting a cada commit/PR."

boas_praticas:
  clean_code: "Manter código limpo, legível e modular conforme 'Clean Code'."
  solid: "Aplicar princípios SOLID em cada módulo."
  type_safety: "Utilizar TypeScript para detecção precoce de erros."


  testes:
    pitfalls_comuns:
      - problema: "Testes de integração com dados residuais"
        solucao: "Limpar banco antes de cada teste"
        exemplo: "beforeEach(() => clearDatabase())"

      - problema: "Validação de CNPJ inconsistente"
        solucao: "Usar regex e validação de dígitos"
        exemplo: "@IsValidCNPJ()"

      - problema: "Paginação com parâmetros inválidos"
        solucao: "Usar DTO com validação"
        exemplo: "class PageOptionsDto"

      - problema: "Soft delete afetando unique constraints"
        solucao: "Considerar deleted_at nas queries"
        exemplo: "where: { deleted_at: null }"

    estrategia_geral:
      descricao: >
        Abordagem abrangente de testes para garantir qualidade e confiabilidade do sistema,
        com foco em testes determinísticos e cobertura significativa.
      cobertura_minima: "80% por módulo"
      execucao_automatica: "Via GitHub Actions em cada commit"
    
    unitarios:
      backend:
        objetivo: "Validar funções e métodos essenciais de cada módulo de forma isolada"
        ferramenta: "Jest v29.x"
        escopo:
          - "Serviços de domínio"
          - "Repositórios"
          - "Controllers"
          - "DTOs e validações"
        praticas:
          - "Utilização de mocks para dependências externas"
          - "Isolamento completo de camadas"
          - "Testes determinísticos"
        scripts:
          test: "jest --coverage"
          test_watch: "jest --watch"
      
      frontend:
        objetivo: "Validar componentes React e suas interações"
        ferramentas:
          - "Jest v29.x"
          - "@testing-library/react"
          - "@testing-library/user-event"
        escopo:
          - "Componentes individuais"
          - "Hooks customizados"
          - "Funções utilitárias"
          - "Validações de formulário"
        praticas:
          - "Testes baseados em comportamento"
          - "Simulação de interações do usuário"
          - "Mocks de chamadas à API"
        scripts:
          test: "react-scripts test --env=jsdom"
          test_coverage: "react-scripts test --env=jsdom --coverage"

    integracao:
      backend:
        objetivo: "Verificar a comunicação entre API e banco de dados"
        ferramenta: "SuperTest integrado ao Jest"
        escopo:
          - "Endpoints da API"
          - "Middleware de autenticação"
          - "Validações de entrada"
          - "Transações de banco de dados"
        ambiente: 
          descricao: "SQLite dedicado para testes"
          config: ".env.test com conexão SQLite específica"
        scripts:
          test: "jest --config jest.integration.config.js"
          migrate: "prisma migrate deploy --env-file .env.test"
      
      frontend:
        objetivo: "Validar integração entre componentes e módulos"
        ferramentas:
          - "Jest"
          - "Testing Library"
          - "MSW (Mock Service Worker)"
        escopo:
          - "Fluxos de navegação"
          - "Comunicação entre componentes"
          - "Integração com contextos/estados"
        praticas:
          - "Mocks de serviços externos"
          - "Simulação de estados da aplicação"
          - "Testes de rotas e navegação"

    e2e:
      objetivo: "Simular fluxos críticos do sistema de ponta a ponta"
      ferramenta: "Jest + SuperTest"
      cenarios_criticos:
        - "Criação completa de pedido"
        - "Repetição de pedido existente"
        - "Geração e visualização de PDF"
        - "Paginação nas listagens"
      ambiente:
        descricao: "Banco de dados limpo para cada suite de testes"
        setup: "Migrations e seeds automatizados"
      scripts:
        test: "jest --config jest.e2e.config.js"
        setup_db: "yarn migrate:test && yarn seed:test"

    ci_cd:
      descricao: "Pipeline de integração contínua no GitHub Actions"
      etapas:
        - "Lint e formatação"
        - "Testes unitários com cobertura"
        - "Testes de integração"
        - "Testes E2E"
      gates:
        - "Cobertura mínima de 80%"
        - "Todos os testes passando"
        - "Lint sem erros"
      artefatos:
        - "Relatórios de cobertura"
        - "Logs de teste"
        - "Screenshots de falhas (Frontend)"

    mocks_e_fixtures:
      descricao: "Estrutura de dados para testes"
      tipos:
        - "Mocks de serviços externos"
        - "Factories para entidades"
        - "Seeds para banco de dados de teste"
      localizacao: "./test/fixtures"
      convencoes:
        - "Prefixo 'mock' para serviços mockados"
        - "Prefixo 'factory' para geradores de entidades"
        - "Sufixo '.fixture' para dados estáticos"

    documentacao_testes:
      guias:
        - "Como executar os testes"
        - "Como adicionar novos testes"
        - "Convenções e boas práticas"
        - "Troubleshooting comum"
      localizacao: "./docs/testing.md"
      atualizacao: "Obrigatória a cada nova feature"

melhorias_pos_mvp:
  descricao: >
    Melhorias e funcionalidades adicionais a serem consideradas após a entrega do MVP,
    priorizadas por valor agregado e complexidade de implementação.

  performance_e_otimizacao:
    - "Cache para produtos frequentemente pedidos"
    - "Índices otimizados no banco de dados"
    - "Batch processing para pedidos em massa"

  funcionalidades_adicionais:
    controle_estoque:
      - "Verificação de estoque disponível"
      - "Alertas de estoque baixo"
      - "Previsão de demanda baseada em histórico"

    pedidos:
      - "Histórico detalhado de alterações de status"
      - "Sistema de notificações para mudanças de status"
      - "Agrupamento de pedidos por cliente/data"
      - "Validação de horários de pedido"
      - "Limites configuráveis de quantidade por produto"

    relatorios:
      - "Dashboard com métricas de vendas"
      - "Relatórios personalizáveis"
      - "Exportação em múltiplos formatos"

    integracao:
      - "API para integração com sistemas externos"
      - "Sincronização com sistemas de gestão"
      - "Backup automático na nuvem"

  prioridades:
    alta:
      - "Controle básico de estoque"
      - "Histórico de alterações de status"
      - "Relatórios avançados"
    media:
      - "Sistema de notificações"
      - "Otimizações de performance"
      - "Exportação de dados"
    baixa:
      - "Integrações externas"
      - "Previsão de demanda"
      - "Backup na nuvem"

consideracoes_finais:
  descricao: >
    Esta documentação define um MVP funcional para "Lino's Padaria", com foco nas funcionalidades essenciais
    para um ambiente local e offline.